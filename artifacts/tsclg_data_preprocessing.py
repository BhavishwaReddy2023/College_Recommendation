# -*- coding: utf-8 -*-
"""TSCLG-Data-Preprocessing.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TJrigB21FtPKFJfv3nXY_adBSBZIYVMd
"""

import pandas as pd
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

df1=pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df1_cleaned.csv')
df2=pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df2_cleaned.csv')
df3=pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df3_cleaned.csv')
df4=pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df4_cleaned.csv')
df5=pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df5_cleaned.csv')
df6=pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df6_cleaned.csv')

df1.head()



df = pd.concat([df1, df2, df3, df4, df5, df6], ignore_index=True)
display(df.head())

df.shape

df.columns
df=df.drop(columns=['Inst Code', 'Place',
       'Dist Code', 'BRANCH CODE', 'Branch Name'],axis=1)
df.shape

df.head()



"""### Distribution of Ranks across Branches"""

plt.figure(figsize=(15, 7))
sns.boxplot(x='BRANCH', y='OC BOYS', data=df)
plt.xticks(rotation=90)
plt.title('Distribution of OC Boys Ranks Across Branches')
plt.tight_layout()
plt.show()

"""### Distribution of Ranks across College Types"""

plt.figure(figsize=(10, 6))
sns.boxplot(x='COLLEGE TYPE', y='OC BOYS', data=df)
plt.title('Distribution of OC Boys Ranks Across College Types')
plt.show()

"""### Percentage of Private, University, Coed, and Girls Colleges"""

plt.figure(figsize=(12, 6))
plt.subplot(1, 2, 1)
df['COLLEGE TYPE'].value_counts(normalize=True).plot(kind='pie', autopct='%1.1f%%', title='Percentage of College Types')
plt.ylabel('')

plt.subplot(1, 2, 2)
df['COED'].value_counts(normalize=True).plot(kind='pie', autopct='%1.1f%%', title='Percentage of Coed vs Girls Colleges')
plt.ylabel('')

plt.tight_layout()
plt.show()

"""Let me know which specific caste and branch/college relationships you'd like to visualize with histograms, bar plots, or scatter plots, and we can generate those next."""

boys_rank_columns = ['OC BOYS', 'BC_A BOYS', 'BC_B BOYS', 'BC_C BOYS', 'BC_D BOYS', 'BC_E BOYS', 'SC BOYS', 'ST BOYS']

for rank_col in boys_rank_columns:
    plt.figure(figsize=(15, 7))
    sns.histplot(data=df, x=rank_col, hue='BRANCH', multiple='stack', kde=True)
    plt.title(f'Distribution of {rank_col} Ranks Across Branches')
    plt.xlabel(rank_col)
    plt.ylabel('Frequency')
    plt.tight_layout()
    plt.show()



boys_rank_columns = ['OC BOYS', 'BC_A BOYS', 'BC_B BOYS', 'BC_C BOYS', 'BC_D BOYS', 'BC_E BOYS', 'SC BOYS', 'ST BOYS', 'EWS GEN OU']
girls_rank_columns = ['OC GIRLS', 'BC_A GIRLS', 'BC_B GIRLS', 'BC_C GIRLS', 'BC_D GIRLS', 'BC_E GIRLS', 'SC GIRLS', 'ST GIRLS', 'EWS GIRLS OU']


print("Box plots for Boys Ranks Across College Types:")
for rank_col in boys_rank_columns:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='COLLEGE TYPE', y=rank_col, data=df)
    plt.title(f'Distribution of {rank_col} Ranks Across College Types')
    plt.show()

print("\nBox plots for Girls Ranks Across College Types:")
for rank_col in girls_rank_columns:
    plt.figure(figsize=(10, 6))
    sns.boxplot(x='COLLEGE TYPE', y=rank_col, data=df)
    plt.title(f'Distribution of {rank_col} Ranks Across College Types')
    plt.show()

caste_categories = ['OC', 'BC_A', 'BC_B', 'BC_C', 'BC_D', 'BC_E', 'SC', 'ST', 'EWS GEN']

for caste in caste_categories:
    boys_col = f'{caste} BOYS' if caste != 'EWS GEN' else 'EWS GEN OU'
    girls_col = f'{caste} GIRLS' if caste != 'EWS GEN' else 'EWS GIRLS OU'
    if boys_col in df.columns and girls_col in df.columns:
        plt.figure(figsize=(12, 6))
        sns.boxplot(x='COLLEGE TYPE', y=boys_col, data=df, color='skyblue', showfliers=False)
        sns.boxplot(x='COLLEGE TYPE', y=girls_col, data=df, color='lightcoral', showfliers=False)
        plt.title(f'Comparison of {caste} Ranks (Boys vs Girls) Across College Types')
        plt.ylabel('Rank')
        plt.legend(labels=['Boys', 'Girls'])
        plt.show()
    elif boys_col in df.columns:
        plt.figure(figsize=(10, 6))
        sns.boxplot(x='COLLEGE TYPE', y=boys_col, data=df)
        plt.title(f'Distribution of {boys_col} Ranks Across College Types')
        plt.show()
    elif girls_col in df.columns:
        plt.figure(figsize=(10, 6))
        sns.boxplot(x='COLLEGE TYPE', y=girls_col, data=df)
        plt.title(f'Distribution of {girls_col} Ranks Across College Types')
        plt.show()
    else:
        print(f"Columns for {caste} ranks (Boys and Girls) not found in the dataframe.")

df.dtypes

df.columns



# Select only numerical columns for the heatmap
numerical_cols = df.select_dtypes(include=np.number).columns

# Calculate the correlation matrix
correlation_matrix = df[numerical_cols].corr()

# Create the heatmap
plt.figure(figsize=(12, 10))
sns.heatmap(correlation_matrix, annot=True, cmap='coolwarm', fmt=".2f")
plt.title('Heatmap of Numerical Column Correlations')
plt.show()

# Calculate the average OC BOYS rank for each branch and college type
average_rank_pivot = df.pivot_table(values='OC BOYS', index='BRANCH', columns='COLLEGE TYPE', aggfunc='mean')

# Create the heatmap
plt.figure(figsize=(15, 10))
sns.heatmap(average_rank_pivot, annot=True, cmap='viridis', fmt=".0f")
plt.title('Average OC BOYS Rank Across Branches and College Types')
plt.xlabel('College Type')
plt.ylabel('Branch')
plt.show()

caste_categories = ['OC', 'BC_A', 'BC_B', 'BC_C', 'BC_D', 'BC_E', 'SC', 'ST', 'EWS GEN']

for caste in caste_categories:
    boys_col = f'{caste} BOYS' if caste != 'EWS GEN' else 'EWS GEN OU'
    girls_col = f'{caste} GIRLS' if caste != 'EWS GEN' else 'EWS GIRLS OU'

    if boys_col in df.columns:
        average_rank_pivot_boys = df.pivot_table(values=boys_col, index='BRANCH', columns='COLLEGE TYPE', aggfunc='mean')
        plt.figure(figsize=(15, 10))
        sns.heatmap(average_rank_pivot_boys, annot=True, cmap='viridis', fmt=".0f")
        plt.title(f'Average {boys_col} Rank Across Branches and College Types')
        plt.xlabel('College Type')
        plt.ylabel('Branch')
        plt.show()
    else:
        print(f"Column '{boys_col}' not found in the dataframe.")

    if girls_col in df.columns:
        average_rank_pivot_girls = df.pivot_table(values=girls_col, index='BRANCH', columns='COLLEGE TYPE', aggfunc='mean')
        plt.figure(figsize=(15, 10))
        sns.heatmap(average_rank_pivot_girls, annot=True, cmap='viridis', fmt=".0f")
        plt.title(f'Average {girls_col} Rank Across Branches and College Types')
        plt.xlabel('College Type')
        plt.ylabel('Branch')
        plt.show()
    else:
        print(f"Column '{girls_col}' not found in the dataframe.")

caste_categories = ['OC', 'BC_A', 'BC_B', 'BC_C', 'BC_D', 'BC_E', 'SC', 'ST', 'EWS GEN']

for caste in caste_categories:
    boys_col = f'{caste} BOYS' if caste != 'EWS GEN' else 'EWS GEN OU'
    girls_col = f'{caste} GIRLS' if caste != 'EWS GEN' else 'EWS GIRLS OU'

    if boys_col in df.columns:
        min_rank_pivot_boys = df.pivot_table(values=boys_col, index='BRANCH', columns='COLLEGE TYPE', aggfunc='min')
        plt.figure(figsize=(15, 10))
        sns.heatmap(min_rank_pivot_boys, annot=True, cmap='viridis_r', fmt=".0f")
        plt.title(f'Minimum {boys_col} Rank Across Branches and College Types')
        plt.xlabel('College Type')
        plt.ylabel('Branch')
        plt.show()
    else:
        print(f"Column '{boys_col}' not found in the dataframe.")

    if girls_col in df.columns:
        min_rank_pivot_girls = df.pivot_table(values=girls_col, index='BRANCH', columns='COLLEGE TYPE', aggfunc='min')
        plt.figure(figsize=(15, 10))
        sns.heatmap(min_rank_pivot_girls, annot=True, cmap='viridis_r', fmt=".0f")
        plt.title(f'Minimum {girls_col} Rank Across Branches and College Types')
        plt.xlabel('College Type')
        plt.ylabel('Branch')
        plt.show()
    else:
        print(f"Column '{girls_col}' not found in the dataframe.")



caste_categories = ['OC', 'BC_A', 'BC_B', 'BC_C', 'BC_D', 'BC_E', 'SC', 'ST', 'EWS GEN']

for caste in caste_categories:
    boys_col = f'{caste} BOYS' if caste != 'EWS GEN' else 'EWS GEN OU'
    girls_col = f'{caste} GIRLS' if caste != 'EWS GEN' else 'EWS GIRLS OU'

    # Check if both columns exist in the dataframe
    if boys_col in df.columns and girls_col in df.columns:
        plt.figure(figsize=(15, 7))
        sns.boxplot(x='BRANCH', y=boys_col, data=df, color='skyblue', showfliers=False)
        sns.boxplot(x='BRANCH', y=girls_col, data=df, color='lightcoral', showfliers=False)
        plt.xticks(rotation=90)
        plt.title(f'Comparison of {caste} Ranks (Boys vs Girls) Across Branches')
        plt.ylabel('Rank')
        plt.legend(labels=['Boys', 'Girls'])
        plt.tight_layout()
        plt.show()
    elif boys_col in df.columns:
        plt.figure(figsize=(15, 7))
        sns.boxplot(x='BRANCH', y=boys_col, data=df)
        plt.xticks(rotation=90)
        plt.title(f'Distribution of {boys_col} Ranks Across Branches')
        plt.tight_layout()
        plt.show()
    elif girls_col in df.columns:
        plt.figure(figsize=(15, 7))
        sns.boxplot(x='BRANCH', y=girls_col, data=df)
        plt.xticks(rotation=90)
        plt.title(f'Distribution of {girls_col} Ranks Across Branches')
        plt.tight_layout()
        plt.show()
    else:
        print(f"Columns for {caste} ranks (Boys and Girls) not found in the dataframe.")

df.columns

from sklearn.feature_extraction.text import TfidfVectorizer
tfidf = TfidfVectorizer(max_features=5000,stop_words='english')
# Combine relevant text columns for TF-IDF
df['text_features'] = df['INSTITUTE NAME'].fillna('') + ' ' + df['BRANCH NAME'].fillna('')
vectors = tfidf.fit_transform(df['text_features']).toarray()

"""You are right, those columns (place, rank, caste, gender, and college type) are not suitable for TF-IDF, which is specifically for text data.

These features are very important for a college recommendation system! We can use them in a few ways:

1.  **Filtering:** We can first filter the colleges based on your preferences for place, college type, and gender (coed/girls). This narrows down the list of potential colleges.
2.  **Scoring/Ranking:** We can incorporate the rank and caste information into a scoring system. For example, we could give higher scores to colleges where your rank falls within the typical range for a specific branch and caste.
3.  **Combined Approach:** A more advanced approach would be to combine the text-based similarity (from TF-IDF) with the other features in a hybrid model.

Would you like to start by filtering the colleges based on some of these criteria?
"""

# Get user preferences
preferred_place = input("Enter preferred place (e.g., HYDERABAD): ").strip()
preferred_college_type = input("Enter preferred college type (e.g., PVT, UNIV, GOV, SF): ").strip()
preferred_coed = input("Enter preferred college type (COED or GIRLS): ").strip()
preferred_branch_input = input("Enter preferred branch(es) (e.g., CSE, ECE, IT - separate with commas): ").strip()
preferred_caste = input("Enter your caste category (e.g., OC, BC_A, SC, ST, EWS GEN): ").strip()
student_rank = int(input("Enter your rank: "))

# Split preferred branches by comma and remove leading/trailing spaces
preferred_branches = [branch.strip() for branch in preferred_branch_input.split(',')]

# Filter the dataframe based on preferences
df_filtered = df[
    (df['PLACE'].str.contains(preferred_place, case=False, na=False)) &
    (df['COLLEGE TYPE'] == preferred_college_type) &
    (df['COED'] == preferred_coed) &
    (df['BRANCH'].isin(preferred_branches)) # Use isin for multiple branch matching
]

# Display the filtered dataframe
display(df_filtered.head())



"""# Task
Create a Streamlit application that recommends colleges based on user-selected preferences for place, college type, coed/girls, branches, and caste, and a user-input rank. The application should load college data, provide interactive selection options for categorical features, and a text input for rank, then filter and recommend colleges based on these inputs.

## Install streamlit

### Subtask:
Install the necessary library for building the web application.

**Reasoning**:
Install the streamlit library using pip.
"""

!pip install streamlit

"""## Create a streamlit app file

### Subtask:
Create a Python file that will contain the Streamlit code.

**Reasoning**:
Create a new Python file named `app.py` and add the necessary import statements.
"""

# app.py
import streamlit as st
import pandas as pd
import numpy as np

"""## Load and preprocess data

### Subtask:
Load the college data and perform any necessary preprocessing steps within the Streamlit app.

**Reasoning**:
Load and preprocess the data as specified in the instructions.

**Reasoning**:
The previous command failed because the path to `df2_cleaned.csv` was incorrect. I will correct the path and re-execute the data loading and preprocessing steps.
"""

import pandas as pd
import numpy as np
import streamlit as st

@st.cache_data
def load_data():
    """Loads and preprocesses the college data."""
    df1 = pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df1_cleaned.csv')
    df2 = pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df2_cleaned.csv')
    df3 = pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df3_cleaned.csv')
    df4 = pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df4_cleaned.csv')
    df5 = pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df5_cleaned.csv')
    df6 = pd.read_csv('/content/drive/MyDrive/ML-DL-PRO/TSCLG-RECOMMENDATION-SYTESM-DS/updated columns-DS/df6_cleaned.csv')

    df = pd.concat([df1, df2, df3, df4, df5, df6], ignore_index=True)

    df = df.drop(columns=['Inst Code', 'Place', 'Dist Code', 'BRANCH CODE', 'Branch Name'], axis=1)

    rank_columns = ['OC BOYS', 'OC GIRLS', 'BC_A BOYS', 'BC_A GIRLS', 'BC_B BOYS', 'BC_B GIRLS',
                    'BC_C BOYS', 'BC_C GIRLS', 'BC_D BOYS', 'BC_D GIRLS', 'BC_E BOYS', 'BC_E GIRLS',
                    'SC BOYS', 'SC GIRLS', 'ST BOYS', 'ST GIRLS', 'EWS GEN OU', 'EWS GIRLS OU']
    for col in rank_columns:
        df[col] = df[col].fillna(1000000) # Fill missing ranks with a large value

    df['text_features'] = df['INSTITUTE NAME'].fillna('') + ' ' + df['BRANCH NAME'].fillna('')

    return df

df = load_data()

"""## Implement user input options

### Subtask:
Add Streamlit widgets for users to select their preferences (place, college type, coed/girls, branches, caste) and input their rank.

**Reasoning**:
Add Streamlit widgets for user preferences as instructed.

**Reasoning**:
The error indicates a type mismatch when sorting the unique values in the 'PLACE' column. This is likely due to some NaN values being present, which are floats, while other values are strings. I need to handle missing values before sorting.
"""

st.title('College Recommendation System')
st.header('Enter Your Preferences')

# Handle potential NaN values in 'PLACE' before sorting
place_options = df['PLACE'].dropna().unique().tolist()
preferred_place = st.selectbox(
    'Preferred Place',
    options=['Select a Place'] + sorted(place_options),
    index=0
)

# Handle potential NaN values in 'COLLEGE TYPE' before sorting
college_type_options = df['COLLEGE TYPE'].dropna().unique().tolist()
preferred_college_type = st.selectbox(
    'Preferred College Type',
    options=['Select College Type'] + sorted(college_type_options),
    index=0
)

preferred_coed = st.radio(
    'Preferred College Type (Coed/Girls)',
    options=['COED', 'GIRLS']
)

# Handle potential NaN values in 'BRANCH' before sorting
branch_options = df['BRANCH'].dropna().unique().tolist()
preferred_branches = st.multiselect(
    'Preferred Branch(es)',
    options=sorted(branch_options)
)

caste_categories_options = ['OC', 'BC_A', 'BC_B', 'BC_C', 'BC_D', 'BC_E', 'SC', 'ST', 'EWS GEN']
preferred_caste = st.selectbox(
    'Your Caste Category',
    options=['Select Caste'] + sorted(caste_categories_options),
    index=0
)

student_rank = st.number_input(
    'Your Rank',
    min_value=1,
    value=10000 # Default value
)

"""## Filter colleges

### Subtask:
Implement the filtering logic based on the user's selections and input rank.

**Reasoning**:
Implement the filtering logic based on the user's selections and input rank, including validation for selectbox defaults and handling the special EWS GEN caste column name.
"""

if st.button('Find Colleges'):
    # 1. Check if the user has selected valid options
    if preferred_place == 'Select a Place' or preferred_college_type == 'Select College Type' or preferred_caste == 'Select Caste':
        st.warning("Please select options for Preferred Place, Preferred College Type, and Your Caste Category.")
    else:
        # 2. Filter the DataFrame based on preferences
        df_filtered = df[
            (df['PLACE'].str.contains(preferred_place, case=False, na=False)) &
            (df['COLLEGE TYPE'] == preferred_college_type) &
            (df['COED'] == preferred_coed)
        ].copy() # Use .copy() to avoid SettingWithCopyWarning

        # 3. Further filter based on preferred branches
        if preferred_branches: # Check if any branches are selected
            df_filtered = df_filtered[df_filtered['BRANCH'].isin(preferred_branches)].copy()

        # 4. Define the caste and gender-specific rank column name
        if preferred_caste == 'EWS GEN':
            rank_column = f'EWS {preferred_coed} OU'
        else:
            rank_column = f'{preferred_caste} {preferred_coed}'

        # Check if the rank column exists in the dataframe
        if rank_column in df_filtered.columns:
            # 5. Filter based on student rank
            df_eligible_colleges = df_filtered[df_filtered[rank_column] >= student_rank].copy()

            # 6. Display results
            if df_eligible_colleges.empty:
                st.info("No colleges found matching your criteria.")
            else:
                st.subheader("Recommended Colleges:")
                # Display relevant columns for recommended colleges
                display_cols = ['INSTITUTE NAME', 'PLACE', 'DIST', 'BRANCH', 'BRANCH NAME', rank_column, 'TUITION FEE']
                st.dataframe(df_eligible_colleges[display_cols])
        else:
            st.error(f"Rank column '{rank_column}' not found in the data.")

"""## Implement recommendation logic

### Subtask:
Based on the filtered data and the user's rank and caste, implement the core recommendation logic. This might involve scoring or ranking the filtered colleges.

**Reasoning**:
Implement the scoring system based on the user's rank and the college's rank for the preferred caste and gender, incorporating tuition fee as a factor, apply it to the filtered dataframe, and sort the results to generate recommended colleges.
"""

if st.button('Find Colleges'):
    # 1. Check if the user has selected valid options
    if preferred_place == 'Select a Place' or preferred_college_type == 'Select College Type' or preferred_caste == 'Select Caste':
        st.warning("Please select options for Preferred Place, Preferred College Type, and Your Caste Category.")
    else:
        # 2. Filter the DataFrame based on preferences
        df_filtered = df[
            (df['PLACE'].str.contains(preferred_place, case=False, na=False)) &
            (df['COLLEGE TYPE'] == preferred_college_type) &
            (df['COED'] == preferred_coed)
        ].copy() # Use .copy() to avoid SettingWithCopyWarning

        # 3. Further filter based on preferred branches
        if preferred_branches: # Check if any branches are selected
            df_filtered = df_filtered[df_filtered['BRANCH'].isin(preferred_branches)].copy()

        # 4. Define the caste and gender-specific rank column name
        if preferred_caste == 'EWS GEN':
            rank_column = f'EWS {preferred_coed} OU'
        else:
            rank_column = f'{preferred_caste} {preferred_coed}'

        # Check if the rank column exists in the dataframe
        if rank_column in df_filtered.columns:
            # 5. Filter based on student rank (consider colleges where student rank is better or close to the college's rank)
            # We will filter based on rank in the scoring step to include colleges slightly outside the strict rank cutoff
            df_eligible_colleges = df_filtered.copy()

            # 6. Implement the scoring system
            # Simple scoring: Higher score for better rank (lower number) and lower tuition fee
            # Adjust the weight of rank and tuition fee as needed
            # We can inverse the rank so lower rank (better) gets a higher score
            # Handle potential non-finite values in the rank column before scoring
            df_eligible_colleges[rank_column] = df_eligible_colleges[rank_column].replace([np.inf, -np.inf], np.nan).fillna(1000000)

            # Define a maximum possible rank to normalize
            max_rank = 1000000 # Based on how missing values were filled

            # Normalize the rank score (higher is better)
            # Avoid division by zero if all ranks are the same or max_rank is 0
            df_eligible_colleges['Score_Rank'] = df_eligible_colleges[rank_column].apply(lambda x: max_rank - x if x <= max_rank else 0)

            # Normalize tuition fee (higher is better, so inverse)
            # Handle potential non-finite values in the tuition fee column before scoring
            df_eligible_colleges['TUITION FEE'] = df_eligible_colleges['TUITION FEE'].replace([np.inf, -np.inf], np.nan).fillna(df_eligible_colleges['TUITION FEE'].max())
            max_tuition_fee = df_eligible_colleges['TUITION FEE'].max()
            # Avoid division by zero if all tuition fees are the same or max_tuition_fee is 0
            if max_tuition_fee > 0:
                df_eligible_colleges['Score_Tuition'] = df_eligible_colleges['TUITION FEE'].apply(lambda x: max_tuition_fee - x)
            else:
                 df_eligible_colleges['Score_Tuition'] = 0


            # Combine scores (adjust weights as needed)
            df_eligible_colleges['Total_Score'] = (df_eligible_colleges['Score_Rank'] * 0.7) + (df_eligible_colleges['Score_Tuition'] * 0.3) # Example weights

            # Filter again to only include colleges where the student's rank is better than or equal to the college's rank
            df_recommended_colleges = df_eligible_colleges[df_eligible_colleges[rank_column] >= student_rank].sort_values(by='Total_Score', ascending=False).copy()


            # 7. Display results
            if df_recommended_colleges.empty:
                st.info("No colleges found matching your criteria.")
            else:
                st.subheader("Recommended Colleges:")
                # Display relevant columns for recommended colleges
                display_cols = ['INSTITUTE NAME', 'PLACE', 'DIST', 'BRANCH', 'BRANCH NAME', rank_column, 'TUITION FEE', 'Total_Score']
                st.dataframe(df_recommended_colleges[display_cols])
        else:
            st.error(f"Rank column '{rank_column}' not found in the data.")

"""## Run the streamlit app

### Subtask:
Provide instructions on how to run the Streamlit application.

## Summary:

### Data Analysis Key Findings

*   The initial data loading process encountered a `FileNotFoundError` due to an incorrect file path, which was subsequently corrected.
*   Preprocessing involved concatenating six separate CSV files, dropping irrelevant columns (`Inst Code`, `Place`, `Dist Code`, `BRANCH CODE`, `Branch Name`), and filling missing rank values with a large number (1,000,000) to facilitate numerical operations.
*   Handling `NaN` values in categorical columns like 'PLACE' and 'COLLEGE TYPE' using `.dropna()` was necessary before sorting unique values for Streamlit selectbox options to avoid `TypeError`.
*   The application dynamically determines the relevant rank column based on the user's chosen caste and gender preference, including a specific case for 'EWS GEN'.
*   A scoring system was implemented that combines normalized scores based on the student's rank relative to the college's cutoff rank and the college's tuition fee, with weights of 0.7 for rank and 0.3 for tuition fee.
*   Non-finite values in both rank and tuition fee columns were handled during the scoring process to prevent errors.
*   Colleges are filtered to include only those where the student's input rank is better than or equal to the college's rank for their category.
*   The filtered and scored colleges are sorted in descending order based on their `Total_Score` to provide recommendations.

### Insights or Next Steps

*   Consider refining the scoring weights (0.7 for rank, 0.3 for tuition) based on user feedback or further analysis to better reflect user priorities in college selection.
*   Explore adding more features to the scoring system, such as college reputation, location desirability, or specific program details, to provide more nuanced recommendations.
"""